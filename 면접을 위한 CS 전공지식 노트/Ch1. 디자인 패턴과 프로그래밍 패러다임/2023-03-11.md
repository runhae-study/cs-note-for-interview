❓ 137p. modebit 컴퓨터에 연결했을 때 권한을 주고 권한을 받아서 연결하는 걸 말하는 건가?
하지만 실상 스트리머들 해킹당해서 카메라에 자기 방 영상으로 유출되는 경우도 있는 것 같은데 완벽하지 않은거겠지?
  
 Yes. 그래서 커버있는 캠이 많이 나왔다. 생각보다 해킹하기 쉬운듯 하다

---

❓ p.137 시스템콜은 하나의 추상화 계층: 이거 무슨 말? 추상화 계층이라서 뭐? 어떤 프로그램? 유저 프로그램?

시스템콜은 인터페이스이므로 커널 모드나 하드웨어적으로 어떻게 동작하는지 몰라도 프로그램을 구현/제어할 수 있다.

---

<aside>
❓ p.141 하드웨어 인터럽트 라인이 설계된 이후 뭥미? 뭔소리지

하드웨어 인터럽트가 생기면 순차적인 인터럽트 실행 중지

운영체제를 통해 시스템콜을 요청 → 디바이스 내 작은 로컬 버퍼에 접근하여 제어/일 수행

이 수행이 끝나면 원래 실행하던 프로그램 재실행
  
<img src="https://user-images.githubusercontent.com/80020227/224462623-17668191-03b7-48c2-9ac1-48fa1e2eb0c6.png" alt="interupt" width="650" />
</aside>

---

<aside>
❓ p.143 그럼 하드디스크에 저장되어 있는 게임이 실행될 때 RAM으로 복사되어 올라가고 그것을 CPU가 실행? 복사하는 상태가 로딩 중?

게임을 실행하게 되면 하드디스크에 저장되어 있던 파일 중 일부를 램에 옮기는/올리는 작업이 수행됨.

그때가 로딩 상태.

[https://pgr21.com/qna/128116](https://pgr21.com/qna/128116)

</aside>

---

<aside>
❓ p.144 i를 지속 접근하기 때문에 캐싱하여 빠르게 +1을 연이어 하는 것?

p.145 그래서 배열의 i 요소들은 메모리 상 연속된 공간? js는 그렇지 않지 않나?

캐시가 효율적으로 동작하기 위해서는 캐시에 저장할 데이터가 지역성(locality)을 가져야 합니다.

지역성은 시간 지역성과 공간 지역성으로 나뉩니다.

**시간 지역성**은 데이터의 읽기/쓰기를 위해 **특정 메모리가 사용됐을 때 가까운 시일 내에 해당 메모리가 다시 사용**될 가능성이 높은 걸 말합니다.

**공간 지역성**은 특정 데이터와 가까운 주소가 순서대로 접근되는 경우를 말합니다. **한 메모리 주소에 접근할 때 그 주소뿐만 아니라 해당 블록을 전부 캐시**에 가져옴으로써 공간 지역성의 효율을 높입니다.

---

[https://velog.io/@yongjin9660/JavaScript-배열이-배열이-아니라고](https://velog.io/@yongjin9660/JavaScript-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC%EA%B3%A0)

</aside>

---

<aside>
❓ 149p 페이지 폴트 - 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에 없는 데이터에 접근했을 때 발생한다.
프로세스 주소공간에 존제하는데 RAM에 없다는말이 무슨경우이지?

### **가상 메모리란**

- 메모리(RAM)로써 실제 존재하지는 않지만 사용자에게 있어 메모리로써의 역할을 하는 메모리(ROM/하드디스크)
- **메인 메모리(RAM)의 저장공간이 부족할 때** 하드디스크에 파일 형태로 따로 준비(확장)하는 가상의 메모리 공간으로, 부족한 시스템 메모리를 보조해주는 역할
- 가상 메모리 안에서 프로그램이 실행될 때는 실제 메모리에 머물러 있어야 한다.
- 그러나 프로그램이 실행될 때 **반드시 프로그램 전체가 실제 메모리에 있을 필요는 없다.** (RAM을 효율적으로 사용하기 위해)
- **현재 실행되어야 하는 부분만이 실제 메모리(RAM)에 옮겨져 있으면 되는 것**이므로 실제 메모리 용량보다 큰 프로그램이 가상 메모리(ROM/하드디스크)를 통해 실행 가능하게 된다.
    
    → 맵핑을 통해 필요한 부분을 빠르고 정확하게 가져와 준다.(대표적으로 Paging 기법)
    

[https://re-atmosphere.tistory.com/m/3](https://re-atmosphere.tistory.com/m/3)

[https://preamtree.tistory.com/21](https://preamtree.tistory.com/21)

---

**쓰레싱이란**

페이지 교체가 필요하지만 이미 활발히 사용되는 페이지들만으로 이루어져 있으므로 어떤 페이지가 교체되던 바로 다시 페이지 교체가 필요하게 될 것입니다.

결과적으로 바로바로 반복해서 페이지 폴트가 발생하며, 교체된 페이지는 또 다시 얼마 지나지 않아 읽어올 필요가 생기게 됩니다. 이렇게 **과도한 페이징 작업**을 Thrasing(쓰레싱) 이라 합니다.

**쓰레싱의 원인**

1) 다중 프로그래밍 정도가 높아짐에 따라 CPU이용률이 높아지게 되고, CPU이용률이 최대값에 도달했을 때, 다중 프로그래밍의 정도가 그 이상으로 커지게 되면 **쓰레싱이 일어나게 되고 CPU이용률은 급격히 떨어집니다.**

2) **운영체제는 CPU이용률을 감시**하며, CPU이용률이 너무 낮아지면 새로운 **프로세스를 시스템에 추가**하여 다중 프로그래밍의 정도를 높이게 됩니다. 이 때 전역 페이지 교체 알고리즘을 사용하여 어떤 프로세스의 페이지인지에 대한 고려없이 교체를 수행하게 됩니다.

[https://jwprogramming.tistory.com/56](https://jwprogramming.tistory.com/56)

</aside>

---

<aside>
❓ p. 152 내부 단편화

고정적으로 나눈 메모리보다 프로세스가 작아서 RAM이 남아돌아 효율적으로 사용하지 못하는 상태

| 내부 단편화 | 외부 단편화 |
|---|---|
| ![internal1](https://user-images.githubusercontent.com/80020227/224462679-556becf6-c6b7-4741-b744-b798476a5700.png) | ![internal2](https://user-images.githubusercontent.com/80020227/224462682-f0e16296-02fa-4426-b408-393330fac00a.png) |


[https://code-lab1.tistory.com/54](https://code-lab1.tistory.com/54)

![internal3](https://user-images.githubusercontent.com/80020227/224462685-e2409bab-5601-4ff3-b890-bf6a3972d5c9.png)

</aside>

---

<aside>
❓ 153p 세그먼트 - 홀크기가 균일하지 않으면 안돼나?

홀에 빈 공간이 생기므로 메모리를 효율적으로 사용하기 어렵다.

</aside>

---

<aside>
❓ 155p 코드 이해하신분? 그냥 오래된것과 아닌것을 구분해서 두는걸 말하는거겠죠?

가장 최근 사용한 데이터를 꺼내기 쉽도록 앞에 배치하고, 사용한지 오래된 데이터를 뒤쪽에 배치해주는 그런 걸 의미하는 코드

</aside>

---

<aside>
❓ p.157 NUR 이게 뭐가 좋지…? 어떻게 해서 LRU에서 발전한거지???

<img src="https://user-images.githubusercontent.com/80020227/224462723-05e228b8-d9ea-43f1-90a6-039fde04b25b.png" alt="nur" width="650" />

클럭 알고리즘은 **LRU처럼 가장 최근에 참조되지 않은 페이지를 대상으로 선정한다는 점에서 LRU와 근사하지만 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 않는다.**

클럭 알고리즘은 그림처럼 참조 비트(reference bit)를 순차적으로 조사하며 동작합니다.

1. 프레임 내의 페이지가 참조될 때 하드웨어에 의해 1로 자동 세팅됩니다.

2. 클럭 알고리즘은 한 바퀴 돌며 참조되지 않은 페이지의 참조 비트 값을 0으로 바꾼 후 지나갑니다.

3. 참조 비트가 0인 페이지를 방문하면 해당 페이지를 교체합니다.

**페이지가 참조되면 1이 되고, 한 바퀴 도는 동안 사용되지 않으면 0**이 되고 다시 한 바퀴를 도는 동안 사용되지 않는 페이지는 참조되지 않았으므로 교체 대상 페이지로 선정하는 알고리즘

[https://zangzangs.tistory.com/143](https://zangzangs.tistory.com/143)

![nur2](https://user-images.githubusercontent.com/80020227/224462727-2c90bda3-360a-4506-9c04-cda94aeeaf49.png)

</aside>
