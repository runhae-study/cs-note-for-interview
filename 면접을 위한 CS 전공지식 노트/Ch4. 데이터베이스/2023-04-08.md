<aside>
❓ 223p. lookup은 사용하지 말아달라고하는데 이유가..? 그리고 이 기능이 무슨 기능이지?

MongoDB에서 lookup의 성능이 좋지 않은 이유

1. 대용량 데이터 처리 문제: $lookup은 join을 수행하기 위해 **모든 데이터를 메모리에 로드**합니다. 만약 큰 데이터 세트를 처리한다면 메모리 부족으로 인해 성능 저하가 발생할 수 있습니다.
2. 인덱싱 부재: $lookup은 참조하는 컬렉션의 인덱스를 사용하여 참조되는 값을 검색합니다. 그러나 적절한 **인덱스가 없을 경우 $lookup의 성능이 저하**됩니다.
3. 데이터 모델링 문제: $lookup은 join을 수행하는 데 사용됩니다. 그러나 **데이터 모델링이 적절하지 않으면** $lookup의 성능이 저하됩니다. 예를 들어, 중첩된 배열을 사용하는 경우 $lookup은 더욱 복잡해지며, 성능이 저하될 가능성이 높습니다.
    
    ⇒ 값을 비교해야 할텐데 그 값이 이중 배열이면 당연히 성능 저하
    
4. 네트워크 지연: $lookup을 수행하는 데는 다른 데이터베이스에 대한 네트워크 요청이 필요합니다. 네트워크 지연이 큰 경우 $lookup의 성능이 저하될 수 있습니다.

⇒ JOIN 대신 데이터 중복, 중첩, 참조 등의 방법을 사용

</aside>

---

<aside>
❓ p.226 중첩 루프 조인 / 랜덤 접근에 대한 비용??

중첩 루프 조인에서는 중첩 루프를 사용하기 때문에 느리다.

루프가 한 번 돌 때마다 매번 디스크에서 읽어야 하는 랜덤 I/O가 발생하게 됩니다. 이러한 랜덤 I/O는 디스크 헤더를 이동하고, 디스크에서 데이터를 읽어오는 등의 추가 작업이 필요하기 때문에 매우 느린 작업입니다.

**랜덤 I/O vs 랜덤 접근(Random Access)**

- 랜덤 I/O(Random I/O)
    
    하드 디스크에서 디스크 헤더를 이동하여 원하는 위치로 이동한 다음 데이터를 읽거나 쓰는 것
    
    디스크 헤더를 이동하는 작업은 매우 느리며, 디스크의 성능에 큰 영향
    
- 랜덤 접근(Random Access)
    
    데이터를 찾거나 접근할 때 순차적으로 접근하는 것이 아니라, 임의의 위치로 바로 접근하여 찾는 것을 말합니다.
    
    파일에서 특정 위치의 데이터를 읽는 경우, 파일의 처음부터 순차적으로 읽지 않고, 원하는 위치로 직접 접근하여 데이터를 읽는 것
    
</aside>

---
