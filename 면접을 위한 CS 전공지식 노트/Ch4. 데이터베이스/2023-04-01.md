<aside>
❓ 199p. 비정형 데이터에서 비구조화 데이터가 뭘 말하는걸까?

텍스트와 숫자가 아니면 (오디오, 동영상,문서 등)을 비구조화 데이터 
데이터베이스 section1,2 에 있는 내용

</aside>

---

<aside>
❓ p.208 커넥션 단위 수행?? 트랜잭션 전파 잘 이해 안감.

트랜잭션 전파

트랜잭션 내부에서 트랜잭션을 또 호출한다면 새로운 트랜잭션이 생성될 수도 있고, 이미 트랜잭션이 있다면 부모 트랜잭션에 합류할 수도 있을 것입니다.
진행되고 있는 트랜잭션에서 다른 트랜잭션이 호출될 때 어떻게 처리할지 정하는 것을 '트랜잭션의 전파 설정'이라고 부릅니다.

⇒ 메서드를 여러 개 호출할 때 하나의 트랜잭션으로 묶고 싶을 경우 사용.

![Untitled](https://user-images.githubusercontent.com/87519250/229262910-1c6cc772-b709-41d6-bb70-db992acf96a7.png)

---

커넥션

애플리케이션과 데이터베이스의 연결을 뜻하는 것으로, 애플리케이션에서 데이터베이스에 접속하고 접속을 종료하는 일련의 과정을 의미.

[https://deveric.tistory.com/86](https://deveric.tistory.com/86)

</aside>

---

<aside>
❓ p. 210 팬텀 리드 그래서 네 개의 테이블이 조회되면 안된다는 건가? 반복 가능하지 않은 조회

![Untitlewwd](https://user-images.githubusercontent.com/87519250/229262914-445fc4f8-e6c4-44c1-8066-332095f4c5bf.png)

한 트랜잭션

- 사용자 A가 학년 2인 학생 조회 쿼리 ⇒ 2개의 튜플 / 레코드가 나옴
- 사용자 B가 학년 2인 학생을 삽입
- 사용자 A가 학년 2인 학생 조회 쿼리 ⇒ 3개의 튜플 / 레코드가 나옴

⇒ 같은 트랜잭션이면 동일한 결과가 나와야 함! 그렇지 않은 것이 팬텀 리드

한 트랜잭션

- 사용자 A가 홍길동의 신장을 조회 쿼리 ⇒ 170
- 사용자 B가 홍길동 신장을 171로 변경
- 사용자 A가 홍길동의 신장을 조회 쿼리 ⇒ 171
    
    ⇒ 같은 트랜잭션이면 동일한 결과가 나와야 함! 그렇지 않은 것이 반복 가능하지 않은 조회 (같은 행에서 발생)
    

<aside>
❓ p.210 다른 행 같은 행이 무엇인지.. 데이터 베이스에서…

다른 행 → 튜플 / 레코드

</aside>

</aside>

---

<aside>
❓ 212p. 체크섬?

**체크섬**
(checksum)은 [중복 검사](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%A5%98_%EC%A0%95%EC%A0%95_%EB%B6%80%ED%98%B8)의 한 형태로, [오류 정정](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%A5%98_%EA%B2%80%EC%B6%9C_%EB%B6%80%ED%98%B8)을 통해, 공간([전자 통신](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%9E%90_%ED%86%B5%EC%8B%A0))이나 시간([기억 장치](https://ko.wikipedia.org/wiki/%EA%B8%B0%EC%96%B5_%EC%9E%A5%EC%B9%98)) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.

체크섬은 수신자가 같은 수의 [비트](http://www.terms.co.kr/bit.htm)가 도착했는지를 확인 할 수 있도록 전송단위 내의 비트 수를 세는 것이다. 만약 계산이 맞으면, 에러없이 원만하게 수신된 것으로 간주된다. [TCP](http://www.terms.co.kr/TCP.htm)와 [UDP](http://www.terms.co.kr/UDP.htm) 통신계층 모두에서 체크섬 계산 및 검증 서비스가 제공된다.

```
// 데이터를 다 더하면... 538
:100130003F0156702B5E712B722B732146013421C7
FF +  10 + 01 + 30 +  3F + 01 + 56 + 70 + 2B + 5E + 71 + 2B + 72 + 2B +73 + 21 + 46 + 01 + 34 + 21 = 538
```

[체크섬 위키](https://ko.wikipedia.org/wiki/%EC%B2%B4%ED%81%AC%EC%84%AC)

- 체크섬 계산법 (⇒ 회사 마다 다를 수 있음)
    - 데이터 다 더함
    - 캐리 니블 버림
    - 2의 보수를 취함
</aside>

---

<aside>
❓ 215p. 데이터 웨어하우징이 뭐지?

데이터 웨어하우징은 여러 장소의 모든 옷을 정리된 하나의 장소에 보관할 수 있는 큰 옷장을 갖는 것과 같습니다. 같은 방식으로 데이터 웨어하우징을 사용하면 다양한 소스의 모든 데이터를 한 곳에 저장할 수 있습니다. 이를 통해 필요할 때 데이터를 쉽게 찾고 사용할 수 있습니다. 데이터 웨어하우징을 사용하면 더 쉽게 이해하고 사용할 수 있도록 데이터를 정리하고 구성할 수도 있습니다. 이를 통해 기업은 데이터에서 얻은 인사이트를 기반으로 더 나은 결정을 내릴 수 있습니다. - chatGPT

⇒ 그냥 데이터 저장 솔루션(데이터를 수집, 구성 및 저장하는 프로세스)

- 높은 가용성과 데이터 복제 기능도 제공
- 확장성이 뛰어나며 내결함성
</aside>

---

<aside>
❓ p.216 그럼 NoSQL은 키 - 값 데이터 저장 방식 데이터 베이스인가??

모든 NoSQL 데이터 베이스가 키 - 값 데이터 저장 방식인 것은 아님.

- 키 - 값 데이터 모델
    
    키-값 데이터 모델은 단순하고 빠른 데이터 검색이 필요한 경우에 적합.
    
    Amazon DynamoDB, Redis, Riak
    
- 도큐먼트 데이터 모델
    
    JSON 형식으로 데이터를 저장하며, 관련 데이터를 하나의 도큐먼트로 그룹화
    
    MongoDB
    
- 열 지향 데이터 모델
    
    키와 열의 조합으로 데이터를 저장하며, 열은 하나 이상의 값을 포함
    
    Apache Cassandra
    

⇒ NoSQL은 확장성이 매우 좋음

</aside>

---

<aside>
❓ 216p. 샤딩,레블리카셋을 지원한다는데 뭔지 알아야지.

- 샤딩은 데이터베이스 시스템에서 성능과 확장성을 향상시키기 위해 샤드라고도 하는 여러 서버에 걸쳐 데이터를 분할하는 데 사용되는 기술입니다.
- 레플리카 셋(Replica Set)
    
    MongoDB 서버 인스턴스를 묶어서 하나의 논리적인 단위로 관리하는 방법
    (복제본 중 하나가 실패하거나 사용할 수 없게 되면 ReplicaSet가 자동으로 새 복제본으로 교체하여 필요한 수의 복제본을 항상 사용할 수 있도록 합니다.)
    
    - 보통 하나의 주(primary) 서버와 하나 이상의 보조(secondary) 서버로 구성
        - 주 서버는 쓰기 작업 처리
        - 보조 서버는 주 서버로부터 데이터를 복제하여 읽기 작업 처리
    - 주 서버가 다운되면 보조 서버 중 하나가 새로운 주 서버가 되어 시스템의 가용성을 유지
</aside>

---

<aside>
❓ 217p. 단어에 대한 설명부족. set, hash 지원

set, hash 모두 데이터 구조를 나타내는 기본적인 유형.

- Set
    
    **중복되지 않는 값을 데이터로 가지는 Collection입니다. 때문에 동일한 값을 입력하면 결과적으로 하나의 값만 남습니다.**
     또한 Set은 집합이라는 의미에서 value를 member라 부릅니다. 해당 Collection은 순서를 가지지 않습니다. 이런 Set Collection은 좋아요를 누른 사람 수, 특정 상품을 본 사람 수 등을 나타내는데 사용될 수 있습니다.
    

- Hash
    
    **내부에 또 다른 Key - value로 이루어진 자료구조**
    Hashes는 key 하나에 여러개의 field와 value로 구성됩니다.
    key 하나에 field와 value 쌍을 40억개(4,294,967,295)까지 저장 가능합니다.
    

[Redis의 기본 명령어](https://sabarada.tistory.com/104)

</aside>

---

<aside>
❓ 220p. 클러스터형 인덱스와 세컨더리 인덱스차이

클러스터형 인덱스와 보조 인덱스는 쿼리 성능을 향상시키는 데 사용.

- 클러스터형 인덱스
    
    하나 이상의 열 값을 기반으로 테이블에서 데이터의 물리적 순서를 결정합니다. 이는 테이블의 행이 클러스터형 인덱스 키에 **물리적**으로 정렬되어 쿼리에 키 열이 포함될 때 데이터에 빠르게 액세스할 수 있음을 의미합니다. 테이블에는 하나의 클러스터형 인덱스만 있을 수 있으며 테이블 데이터의 스토리지 순서를 결정합니다.
    
    ⇒ PK가 있는 테이블은 알아서 정렬되어 있으므로 인덱스를 “생성”하지 않아도 됨.
    
- 세컨더리 인덱스
    
    클러스터형 인덱스 키가 아닌 다른 열에 생성되는 인덱스입니다. 테이블에는 여러 보조 인덱스가 있을 수 있으며 클러스터형 인덱스 키를 사용하지 않는 쿼리 속도를 높이는 데 사용됩니다. 보조 인덱스에는 테이블의 **실제 데이터에 대한 포인터가 있는 인덱싱**된 열의 복사본이 포함되어 있어 인덱싱된 **열을 기반으로 행을 빠르게 조회**할 수 있습니다.
    

클러스터형 인덱스와 보조 인덱스의 주요 차이점은 클러스터형 인덱스가 테이블에 있는 데이터의 물리적 순서를 결정하는 반면 보조 인덱스는 테이블의 실제 데이터를 가리키는 별도의 데이터 구조라는 점입니다. 클러스터형 인덱스는 일반적으로 인덱싱된 열과 관련된 쿼리에 더 빠르고 보조 인덱스는 인덱싱되지 않은 열과 관련된 쿼리에 더 빠릅니다.

</aside>

---

<aside>
❓ 222p. 1번 같은 값 쿼리가 있다면 제일 먼저 인덱스? 왜?

데이터베이스에서 인덱스는 테이블에서 데이터 검색 작업의 속도를 향상시키는 데이터 구조입니다. 필요한 정보가 포함된 페이지를 빠르게 찾을 수 있도록 도와주는 **책의 색인**과 같습니다.

데이터베이스 인덱스는 테이블의 하나 이상의 열에 생성되며 테이블의 해당 행에 대한 포인터와 함께 해당 열의 값 복사본을 저장합니다. 인덱싱된 열과 관련된 쿼리를 실행할 때 데이터베이스는 인덱스를 사용하여 쿼리 기준과 일치하는 행을 빠르게 찾습니다.

인덱스는 데이터베이스가 전체 테이블을 스캔하지 않고도 관련 행을 찾을 수 있도록 하므로 행이 많은 대형 테이블에서 데이터 검색 작업 속도를 높이는 데 사용됩니다. 그러나 인덱스에는 단점도 있습니다. 데이터가 삽입, 업데이트 또는 삭제될 때마다 데이터베이스가 인덱스를 업데이트해야 하므로 추가 저장 공간이 필요하고 쓰기 작업 속도가 느려질 수 있습니다.

테이블에서 실행되는 쿼리에 대해 최상의 성능을 제공하도록 인덱스를 신중하게 설계하는 것이 중요합니다. 인덱스가 너무 많으면 쓰기 작업 속도가 느려지고 스토리지 요구 사항이 증가할 수 있는 반면 인덱스가 너무 적으면 쿼리 성능이 느려질 수 있습니다.

인덱스에서 같음(Equality)을 가장 먼저 생성하는 이유는 **인덱스의 사용 범위를 좁히기 위해**서입니다.

예를 들어, 컬럼 A와 B로 구성된 테이블이 있다고 가정해보겠습니다.

이때, A와 B 중 A가 같음 조건으로 검색되는 빈도가 높다면, 인덱스를 (A, B)로 생성하는 것보다는 (B, A)로 생성하는 것이 검색 속도를 향상시킬 수 있습니다.

만약 인덱스를 (A, B)로 생성한다면, A가 같음 조건으로 검색될 때도 B까지 모두 검색해야 합니다. 하지만 인덱스를 (B, A)로 생성한다면, A가 같음 조건으로 검색될 때 B까지 검색할 필요가 없어지므로 더 빠르게 검색이 가능해집니다.

이는 인덱스의 논리적 구조 때문에 가능한 것입니다. **인덱스는 트리 형태로 구성되는데, 같은 값을 가지는 레코드는 같은 블록(block)에 저장**되기 때문입니다.

그러므로, 인덱스를 생성할 때는 검색 빈도가 높은 조건을 가장 먼저 고려하여 인덱스를 생성하는 것이 검색 속도를 높일 수 있습니다.

</aside>
